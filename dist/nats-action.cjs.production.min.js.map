{"version":3,"file":"nats-action.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["import { info, setFailed, getInput } from '@actions/core';\nimport { exec } from 'child_process';\n\nconst parsePorts = () => {\n  return getInput('port')\n    .split(' ')\n    .map(v => parseInt(v))\n    .filter(v => !isNaN(v) && v >= 0);\n};\n\nconst startServer = (\n  port: number,\n  clusterPort?: number,\n  routePort?: number,\n  masterName?: string\n) => {\n  let options: string[] = [];\n  options.push(...['-d', '-p', `${port}:${port}`]);\n  if (clusterPort)\n    options.push(...['--cluster', `nats://0.0.0.0:${clusterPort}`]);\n  if (routePort && masterName)\n    options.push(...['--routes', `nats://${masterName}:${routePort}`]);\n  options.push('nats');\n  options = ['sudo', 'docker', 'run'].concat(options);\n  exec(options.join(' '), e => {\n    if (e) setFailed(`failed to start server due to ${JSON.stringify(e)}`);\n  });\n};\n\nconst ports = parsePorts();\n\nif (!ports.length) setFailed(`require at least 1 port`);\n\ninfo(`ports ${ports.join(', ')} will be used`);\n\nif (ports.length === 1) {\n  startServer(ports[0]);\n} else {\n}\n"],"names":["port","options","ports","getInput","split","map","v","parseInt","filter","isNaN","parsePorts","length","setFailed","info","join","push","concat","exec","e","JSON","stringify"],"mappings":"iBAWEA,IAKIC,wDAaAC,EA1Ba,kBACVC,WAAS,QACbC,MAAM,KACNC,KAAI,SAAAC,UAAKC,SAASD,MAClBE,QAAO,SAAAF,UAAMG,MAAMH,IAAMA,GAAK,KAsBrBI,GAETR,EAAMS,QAAQC,uCAEnBC,gBAAcX,EAAMY,KAAK,uBAEJ,IAAjBZ,EAAMS,YAnBJV,EAAoB,IAChBc,aAAQ,CAAC,KAAM,MANvBf,EAyBYE,EAAM,QAnBsBF,IAKxCC,EAAQc,KAAK,QACbd,EAAU,CAAC,OAAQ,SAAU,OAAOe,OAAOf,GAC3CgB,OAAKhB,EAAQa,KAAK,MAAM,SAAAI,GAClBA,GAAGN,6CAA2CO,KAAKC,UAAUF"}